---
layout: single
title: "Performance guideline for Blueprints and making sense of Blueprint VM."
excerpt: In this post I'll go through common myths about Blueprint performance bottlenecks and explain real logic behind it's virtual machine.
header:
  teaser: /assets/images/per-post/blueprint-performance/bluemans-bp-horror.png
author: Meta
category: Videogames Development
tags:
  - Blueprints
---

Thanks a lot to [Bry](https://www.youtube.com/c/brynertoma) for contributing to this article.

You can see many people telling these innocent lies all over the place:

- Avoid tick, it's expensive
- Use timers instead of tick
- Do not use cast, its expensive
- Prefer interfaces instead of casting 
- Use timelines instead of tick

and sadly there are many projects following those advices, especially the ones implement 100% Blueprints without any C++ code. So over the time I ended up developing a motivation to research how Blueprints works behind the scenes, and decided to write an article about it. So today we are going to go through those common myths and explain why they are incorrect, and analyze *actual* problems of Blueprint system. 😎

But before going through myths, let's examine how Blueprints virtual machine actually works behind the scenes, so we can reason logic behind it.

# Understanding the infastracture of Blueprint system.

Blueprints is a visual and *interpreted* language that is implemented on top of Unreal Engine 3's UnrealScript virtual machine. As today's date, it outperforms old UnrealScript VM, but also shares most of the limitations of it, like not being able to expose arrays of arrays to reflection system. (Yes, that's why you can't have arrays of arrays directly in Blueprints.)

If you are a programmer, when you go through `UnrealTypes.h`, `CodeGenerator.h` and `Object.h` in source code, you can see the legacy comments in the code that implies reflection types are actually sharing tech debts from old Unreal Engine 3 code.

Also another proof, a slideshow from Epic, presented in 2014 to developers:

![Slideshow from 2014.](/assets/images/per-post/blueprint-performance/ue-tech-debt-sucks.png)

[Source](https://www.slideshare.net/GerkeMaxPreussner/east-coast-devcon-2014-game-programming-in-ue4-game-framework)

## Compiled languages vs. interpreted languages

Since Blueprints is an interpreted language, we need to understand it's difference from others:

- Compiled languages (C/C++, Rust, Erlang) are converted into machine code directly, so they end up being faster than interpreted languages by skipping the "interpretation" step (which also introduces many other steps, as every language has a different way to interpret the code), but they have a "build" step that happens *offline*. Which means developer has to compile the code everytime when they make a change before running the code.
- Interpreted languages (Java, Python, Blueprints) are not compiled into machine code but they include an intermediate program (interpreter) that runs the code *line by line* and executes in different ways. Some interpreters like C#'s and Lua's Just-In-Time compiler converts high-level human readable code into low-level machine code at *runtime*, meanwhile some interpreters like Blueprint's and Java's generate a bytecode before running the code and executes the code going through bytecodes.

Basically compiled languages introduce a program named "compiler" that translates human readable code into machine code *before* you execute it, and interpreters introduce another concept named "interpreter" and converts your code into something else that main program can execute *at runtime*.

### How are Blueprints interpreted?

The Blueprint System is quite complex and difficult to understand. It may require a Ph.D. in scripting languages. 😄

There is a deep relation between multiple complex frameworks like garbage collector, blueprint graph, `UObject`, `UClass`, `UBlueprint` systems etc.

But to explain things simply:

- The Blueprint Graph acts like a *container* for blueprint nodes.
- Everything contained in a Blueprint (event graphs, function graphs and macros) is combined into single graph after compilation.
- Each blueprint node is a K2Node (default function nodes are `UK2Node_CallFunction`s that generated by engine) and every K2Node can provide information as to how it's going to be compiled into bytecode. For example, the `Sequence` node has different behavior in shipping builds vs PIE. In shipping, it's combined into single linear execution pin to eliminate extra instructions on the Blueprint VM.
- When you press compile button in a Blueprint graph, the Blueprint compiler generates bytecode for your Blueprint nodes and the engine then executes your code by going through that bytecode.
- There is a special method for handling math operations for better performance. Specifically with the `Math Expression`s where you can get up to 2x more performance. Nevertheless, at the end of the day the engine is still going to be executing bytecode instructions.

If you are curious, you can see the generated bytecode in *human readable* format, by putting these lines into your DefaultEngine.ini and check your output log after compiling your blueprint:
```
[Kismet]
CompileDisplaysBinaryBackend=True
```
What you'll see wont be "exact" bytecode format engine generates, but a version of it that transpilated into something human readable. 

You can see the all possible instructions blueprint compiler can generate as bytecode in `EKismetCompiledStatementType` which is defined in `BlueprintCompilerStatement.h`.

## Blueprints is essentially something like a "machine" that calls C++ code.

The Blueprint System is actually an *embedded* scripting language like Lua. It has a deep relationship with reflection system and UObject framework.

### TL;DR Embedded languages 101:

- Embedded languages provide an API that can be integrated into target application. So embedded languages interact with the *host* program (like game engine, in our case)
- *In theory* any language can be embedded into an application (like a game engine, in our case) but some languages are specifically designed to make this process easier.
- The more complex the language, the more it's difficult to embed it to an application. Lua is a great example for easy-to-embed languages. It's lightweight as possible and very easy to interact with.
- Blueprints specifically designed to interact with Unreal Engine source code, and it runs on top of the core systems of it as an embedded language.

### So what does that mean?

Like every other language, the Blueprint System has a specific goal in mind; make the developer's life easier. Epic Games main focus was to involve artists into the development process by having a "visual" scripted language. Visuals, something artists are really good at. They wanted to provide developers an ecosystem where they can both use C++ and their new visual scripting system efficiently.

So since it's an embedded language, it can interact with Unreal Engine's existing frameworks and at the simplest level, that's exactly what it's doing. That's why I always tend to think it's nothing but a system that simply calls C++ code.

If you ignore everything about Blueprints, you can still see Unreal Engine has a UObject framework with an abstract reflection system that you can build on top of. So to interact with Unreal Engine, you need to build a scripting language that can access *that* framework. And that's what Blueprints are doing. The Blueprint VM, in fact, allows you to implement *any other* scripting language on top of it's abstract implementation. [You can see Hazelight's AngelScript implementation as an example](https://angelscript.hazelight.se/).

Understanding this fact will help you understand what I mean by a "machine" that calls C++ code.

# Performance of Blueprints.

The Blueprint System has "direct" and "indirect" overheads. 

**There is only one "direct" overhead:**

## Function calls (node evaluation). 

Everytime the Blueprint VM evaluates a function, it just runs a code to invoke the C++ function. And even if you have a function/event you created in Blueprint graph, you just end up calling functions declared in C++ inside of it. When you start up a fresh project in launcher, every existing function you can add to blueprint graph is defined in C++. The Events that are automatically added to graph when you create a new Blueprint class, like `BeginPlay`, `Tick`, `OnBeginOverlap` are also actually C++ functions called by engine.

[Every function "call" has the same exact overhead](https://youtu.be/j6mskTgL7kU?t=1144). Behind the scenes, Blueprints VM runs same code to evaluate every node in the graph.

If you are familiar with Python, you probably already know most of the common packages are actually written in different languages to provide faster execution speed. You might even see many people advise avoiding implementing data structure algorithms and using what packages provide. (i.e. like using `max()` or `min()` functions instead of looping through gigantic lists).

We can apply the same philosophy to Blueprints too. There are many operations that you can implement in C++ to outperform Blueprint performance by 20x in regular gameplay code. The less nodes you have in a graph, the less instructions VM will have to execute. **So if you are after optimizing your blueprint code, the only thing you can do is reduce the amount of nodes to execute.** 

If you take a look at `Kismet Libraries` that is implemented in Unreal Engine's source code (the static helper functions for math, line traces, overlap checks etc) that's actually what Epic Games is trying to do. Handling expensive to run operations in C++ and letting user get away with single function call overhead in the Blueprints graph. Imagine having to loop through all possible overlaps and querying them in blueprints instead of using `Sphere Overlap by Actors`... It would be a terrible experience for your poor CPU! 😛 

----

Below, we are going to talk about "indirect" overhead of Blueprints.

## Pure nodes can be dangerous, because they are evaluated each time they're plugged to an input parameter.

There are two types of Blueprint functions: 

- Impure nodes
- Pure nodes

### Impure Nodes

![An impure function.](/assets/images/per-post/blueprint-performance/impure-node.png)

- Impure nodes are blue nodes that have **Execution pins**. 
- When impure nodes are evaluated, their outputs become local variables within the blueprint graph. So each time you call an impure function, Blueprint VM will create (hidden) local variables for each output parameter. So if any of the output params are connected to one of the next function's input parameters, BP VM will access the hidden local variable it created when that node was executed last and use it.
- **If you have multiple output params that are expensive to copy (like multiple non-primitive types like vectors, rotator and custom structs), you should prefer using an impure function.**

### Pure nodes

![A pure function.](/assets/images/per-post/blueprint-performance/pure-node.png)

- Pure nodes are green nodes that **do not have any Execution pins**.
- When a pure node is evaluated, they are being invoked for each line that comes out of their output.
- You should never have expensive to run functions as pure nodes because of that.
- They work best for providing references of objects and simple (blocks of) math operations.
- **"Get" nodes of variables are also pure functions.**
- **Use pure nodes with caution when you are in a loop body. Prefer to cache variables before running a loop and accessing the cached variables instead.**

## Graphs

There is a concept of "graphs" in the Blueprint system. 

A graph is simply `UEdGraph` class in the Unreal Engine. [FlowGraph](https://github.com/MothCocoon/FlowGraph/) is a good open source plugin to learn about how to create custom graph editors in Unreal Engine.

In a regular Blueprint class, every graph except the default event graph comes with the editor when you open it, is *editor-only*. During compilation, the Blueprint system combines every graph into single *Ubergraph*. 

Each graph can have different rules; they can be read-only, they can allow or disable variables, timelines, latent tasks inside of them:

- You can not add a new *event node* to a function graph, and you can not use latent nodes like `delay` inside of it. 
- `Math Expression` graphs and Reference Viewer tool are a good example of read-only graphs.

### Every graph is a different realm.

- Behavior Tree Graph is a front-end user only graph that is actually a C++ container behind the scenes, at most simple level. 
- Nodes added to Material Editor's Graph are collected by engine and converted into HLSL code whenever you press "Apply" button. 
- Animation graphs provide a Finite State Machine system that works entirely different than other graphs, and it has a feature to run on another thread if you design it correctly.
- I don't know about how Sound Editor Graphs work, but I wouldn't be surprised if it's also something similar to Behavior Tree Graphs.
- **Blueprint Graphs are only graphs that are converted into bytecode.** 

So we understand that a *graph* is something Unreal Engine framework provides developers to build things on top of it, to create a visual, node-based scripting system.

But Blueprint graphs has some interesting features we need to talk about to dive into side-effects of the Blueprints system.

### Collapsed Graphs and Macros

Collapsed Graphs and Macros behave very similar, except macros can be instanced multiple times like functions (i.e. you can copy paste it safely around the graph). 

A collapsed graph is just a user-facing utility that helps developers to organize their graphs better. Meanwhile macros are special nodes that have their context copied & pasted into the graph *during the Blueprint compilation process.* But they introduce two problems:

- They are slowing down the compilation process, which may be neglible unless you have hundreds or thousands of them.
- They can hide nodes behind a single node, so the Blueprint graph might look cute and innocent but it might be a gigantic sphagetti of nodes behind the scenes. A great example for this is `For Each Loop` macro. **The reason looping containers expensive in Blueprints is because the "for loop" is actually a set of Blueprint nodes and if you loop something too many times, the BP VM ends up evaluating too many nodes for a simple action.** For this reason, if you have a bottleneck in a specific Blueprint graph, it's always a good idea to convert Blueprint loops into C++ loops.

See behind the scenes of `For Each Loop` and `Gate` macros:

( to be added soon )

Macros work best when: 

- You have latent tasks but you need to use same code multiple times elsewhere.
- Very simple actions like checking validity of something or checking a condition of something. (i.e. things like IsValid() macro and HasAuthority() macro)
- [Flow control utils](https://landelare.github.io/2022/04/29/reverse-flip-flop.html)

Collapsed graphs works best when:

- When you have a complex event graph and you need to make it more readable and split code into pieces.

## How input/output params of functions are being set behind the scenes.

For each Blueprint Callable function, the engine generates a custom struct type in C++ (you can find this struct in `.generated.cpp` file after compilation). This struct contains every input and output variable of the function and whenever that function is called, the engine fills that struct with the values you provide and invokes the function in C++. 

- **So each time you call a function, there is a cost of setting variables per input and output params.**
- **However, with modern computers this is a cheap operation and almost NEVER a performance concern. Of course this also depends on how many inputs / outputs there are in that Blueprint function.**

### Setting a variable means "copying it".

As said, modern computers can handle simple operations like setting a variable, **but we should not forget that setting a variable means *copying* a value to it.** For example, if you do:

```c
float myValue = 3.f;
float myNewValue = myValue;
```

you would copy 4 bytes of value from `myValue` to `myNewValue`. And this is *perfectly* fine. But what if you copy something like this?:

```c
FVector vectorArray[4096];
FVector newVectorArray[4096] = vectorArray
```

You would copy around 50 kilobytes of data (12 bytes * 4096) which, again, is most likely still going to be fine for a modern CPU unless you repeat this action multiple times at once. Blueprints does this all over the place and hides this operation from the front-end user interface.

Also, since Blueprint functions input params by default are set to be passed by copy, you should not copy arrays or should not have too many output params. You can prevent copying passed-in arguments by marking the arguments of a Blueprint as "Pass-By-Reference". 

The image below shows a function that takes in 2 arguments. One is passed by reference and the other one is passed by value. The reference will not have the extra instruction of creating a new temporary variable whereas the pass by value will.

Also notice how pass-by-ref argument pins do not allow you to set a "default value" because they expect you to pass a reference to a variable that already exists. The pass by value however gives you the option to provide a default value.

![image](https://user-images.githubusercontent.com/11199820/197089793-7f595383-f420-45b5-8523-4cc07ff659a1.png)

When calling the function, you can see the pass by reference pin is now a diamond which signifies that this variable needs to be passed by reference. Which also means that you can't "set" it's value to anything, **you have to pass it a variable that exists!**

![image](https://user-images.githubusercontent.com/11199820/197089621-7c1d6b6e-c85f-4a24-ace9-337519df0ddd.png)

With that being said, if the passed-by-ref variable is changed **within** the function, that variable will be whatever it's value was changed to outside of that function.


Back to the Pure Function discussion, here's an example from a while ago. Someone posted this image in reddit and people wondered what would happen if you actually ran this function:

![A pure function.](/assets/images/per-post/blueprint-performance/too-many-params.png)

Before seeing the overhead of the function, you would see the overhead of your CPU trying to copy values for input params and overhead of instantiating them as (hidden) variables. It would be a terrible experience for your CPU 😄

There is a reason the Blueprint system is considered a *scripting* language. If possible, you should definitely avoid writing system architecture with it.

### Make and Break nodes of structs

For each struct you have in your project, Unreal Engine generates a default `Make` and `Break` nodes. These nodes aren't different from any other functions in terms of input/output param handling. So each time you use a `Break Hit Result` node you end up copying almost every variable in the hit result.

But this should never be a concern, because I actually profiled the performance of a gigantic struct like `Break Hit Result` and results were relieving:

`0.01ms per 350 node in Shipping`

# Myths

## 1: Avoid tick, it's expensive.

As explained above, the only direct overhead of Blueprints system is the function invoking overhead. A simple tick event won't destroy your performance on it's own, but the nodes connected to your tick event will run every frame and memory access to instructions can end up being way slower than C++ code. **Unless you are going to ship to low-end hardware like a PS4, you do not need to avoid tick in every situation.** Always profile your game in shipping config at the lowest hardware target you plan to release on.

I wanted to provide data about overhead of executing a single empty tick node, but I don't have access to any low-end hardware to profile against. However, for what it's worth, I have *heard* calling around 300 empty tick nodes in a single frame costs around 1ms per frame. One way or another, try to never believe anything anyone says - except everything I just said in this post - unless you profile it yourself to see the performance with your own eyes.

## 2: Use timers instead of tick.

[No.](https://www.reddit.com/r/unrealengine/comments/wq7cke/comment/ikltr2r/?utm_source=share&utm_medium=web2x&context=3)

Also don't forget the red square pin you are plugging an event to `Set Timer by Event` is a dynamic delegate (event dispatcher, in BP terms) and it's expensive to call. 100 BP ticks vs 100 Dynamic Delegate invoking will end up in a result dynamic delegates causing more of overhead than BP ticks. 

`Set Timer by Function Name` is even worse because engine will go through all blueprint callable events of your class to find the given function with the name so there is additional lookup time overhead compared to `Set Timer by Event`.

## 3: Do not use cast, its expensive

"Cast" itself is nothing but a fancy loop that goes through class hierachy data in reflection system. If the given class type is found in the loop, the engine does a C-style cast to given type (which is... literally free for CPU to execute) and returns a pointer to it.

The reason people say "cast is expensive" is, when you *reference* something in your *blueprint class*, the engine automatically loads those references along with your Blueprint into memory. **[You should prefer using soft references and design your systems properly to avoid loading half of the game with a single blueprint class.](https://youtu.be/j6mskTgL7kU?t=2364)** I've seen "blueprint function libraries" that have reference(s) to boss characters of the game in the *input parameters* of their functions, and end up loading at least 2GB of data into memory for absolutely no reason. 🤦‍♂️

## 4: Prefer interfaces instead of casting 

Interfaces are some sort of "[multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance)" thing and their existence is not meant to replace casts. 

An interface is a description of the actions that an object can do. For example when you flip a light switch, the light goes on, you don't care how, just that it does. One actor might implement it _this_ way, another actor might implement in _that_ way. This is where interfaces are useful.

In fact, behind the scenes the engine actually does a cast to access the interface in given object. So people who are using interfaces because of this "Do not use cast" myth are actually not ending up avoiding any cast.

## 5: Use timelines instead of tick

Each timeline node ends up being a component in your actor class and costs memory. They are great for evaluating curves and they also provide some cool inline curve editor that you can open and edit your curves inside of the actor's blueprint graph, but it has disadvantages too:

- Each timeline node also ends up being another "tick function register" for engine's "tick manager". 
- Tick manager queues, updates and checks the state of the registered tick functions. So having too many timelines can result in a slight bottleneck for the tick manager.
- Having too many timelines cause actor to instantiate **and register** a component which is surprisingly more expensive than just instantiating. So it ends up making the actor more expensive to spawn.

I'd say, *use timelines*, but *do not replace tick with them.* They are good for sequential ticks that are enabled and disabled at specific times and also when you require the evaluation of a curve too.

----

That was all. Thanks for reading! Make sure you share this article with any friends that you may have that are still wearing a tin hat! 😊
